---
export const prerender = true;

import { getCollection } from 'astro:content';
import Base from '../layouts/Base.astro';
import { formatDateShort, calculateReadingTime } from '../utils/shared';

const posts = await getCollection('posts', ({ data }) => {
  return data.published !== false;
});

// Sort posts by date (newest first)
const sortedPosts = posts.sort((a, b) => 
  new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
);

// Group posts by year and month
const postsByYear = sortedPosts.reduce((acc, post) => {
  const date = new Date(post.data.date);
  const year = date.getFullYear();
  const month = date.toLocaleString('default', { month: 'long' });
  
  if (!acc[year]) acc[year] = {};
  if (!acc[year][month]) acc[year][month] = [];
  
  acc[year][month].push(post);
  return acc;
}, {} as any);

// Calculate statistics
const stats = {
  total: posts.length,
  byType: posts.reduce((acc, post) => {
    acc[post.data.type] = (acc[post.data.type] || 0) + 1;
    return acc;
  }, {} as any),
  thisYear: posts.filter(post => 
    new Date(post.data.date).getFullYear() === new Date().getFullYear()
  ).length
};

const years = Object.keys(postsByYear).sort((a, b) => parseInt(b) - parseInt(a));

// Prepare search data for client-side
const searchIndex = posts.map(post => ({
  slug: post.slug,
  title: post.data.title,
  content: post.body,
  type: post.data.type,
  tags: post.data.tags || [],
  date: post.data.date.toISOString(),
  url: `/posts/${post.slug}`,
  description: post.data.description || ''
}));
---

<Base title="Archive — Rabbit Holes" description="Browse all blog posts organized by date.">
  <div class="archive-container">
    <div class="page-header">
      <div class="page-label">Archive</div>
      <h1>All Rabbit Holes</h1>
      <p class="page-description">Every essay, link, and observation collected here. Search or browse by year.</p>
    </div>

    <div class="search-box">
      <div class="search-input-wrapper">
        <input type="text" class="search-input" placeholder="Search archives..." id="archive-search" />
        <span class="search-icon">⌘</span>
      </div>
    </div>

    <div class="filter-tabs">
      <button class="filter-tab active" onclick="filterArchive('all')">All</button>
      <button class="filter-tab" onclick="filterArchive('taught-by-machine')">Essays</button>
      <button class="filter-tab" onclick="filterArchive('link-dumps')">Links</button>
      <button class="filter-tab" onclick="filterArchive('quick-thoughts')">Notes</button>
    </div>

    <div class="archive-content">
      {years.map(year => (
        <div class="archive-section">
          <div class="year-header">{year}</div>
          <div class="archive-list">
            {sortedPosts.filter((post: any) => new Date(post.data.date).getFullYear().toString() === year).map((post: any) => (
              <a href={`/posts/${post.slug}`} class="archive-item" data-type={post.data.type}>
                <div class="archive-date">{new Date(post.data.date).toLocaleDateString('en-US', { month: 'long', day: 'numeric' })}</div>
                <h2 class="archive-title">{post.data.title}</h2>
                <p class="archive-excerpt">{post.data.description || (() => {
                  const cleaned = (post.body || '')
                    .replace(/#+\s*/g, '')                      // Remove headings
                    .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1')   // Extract link text
                    .replace(/\\\[(\d+)\\\]/g, '')              // Remove escaped footnote refs like \[1\]
                    .replace(/\[(\d+)\]/g, '')                  // Remove regular footnote refs like [1]
                    .replace(/^>\s*/gm, '')                     // Remove blockquote markers
                    .replace(/:\s*$/gm, '')                     // Remove trailing colons
                    .replace(/^\s*\d+\\?\.\s*/gm, '')           // Remove numbered lists
                    .replace(/^\s*[:•\-]\s*/gm, '')             // Remove bullet points
                    .replace(/\*\*([^\*]+?)\*\*/g, '$1')        // Remove bold markdown
                    .replace(/\*([^\*]+?)\*/g, '$1')            // Remove italic markdown
                    .replace(/\\/g, '')                         // Remove any remaining backslashes
                    .replace(/\n/g, ' ')                        // Newlines to spaces
                    .replace(/\s+/g, ' ')                       // Normalize spaces
                    .trim();
                  return cleaned.slice(0, 150);
                })()}…</p>
              </a>
            ))}
          </div>
        </div>
      ))}
    </div>
  </div>

  <style>
    .archive-container {
      max-width: var(--width-content);
      margin: 0 auto;
      padding: 80px 40px 120px;
    }

    .page-header {
      margin-bottom: 60px;
    }

    .page-label {
      font-family: 'Outfit', sans-serif;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--color-text-light);
      margin-bottom: 24px;
    }

    h1 {
      font-family: 'Outfit', sans-serif;
      font-size: 52px;
      font-weight: 700;
      line-height: 1.1;
      letter-spacing: -0.025em;
      margin-bottom: 24px;
      color: var(--color-text-primary);
    }

    .page-description {
      font-size: 21px;
      line-height: 1.6;
      color: var(--color-text-tertiary);
      max-width: 540px;
    }

    .search-box {
      margin-bottom: 60px;
      padding-bottom: 60px;
      border-bottom: 1px solid #e8e8e8;
    }

    .search-input-wrapper {
      position: relative;
    }

    .search-input {
      width: 100%;
      font-family: 'Crimson Pro', Georgia, serif;
      font-size: 18px;
      padding: 16px 48px 16px 20px;
      border: 1px solid #d0d0d0;
      background: var(--color-bg);
      color: var(--color-text-secondary);
      outline: none;
    }

    .search-input:focus {
      border-color: var(--color-accent);
    }

    .search-input::placeholder {
      color: var(--color-text-light);
    }

    .search-icon {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--color-text-light);
      font-size: 18px;
    }

    .filter-tabs {
      display: flex;
      gap: 12px;
      margin-bottom: 60px;
      flex-wrap: wrap;
    }

    .filter-tab {
      font-family: 'Outfit', sans-serif;
      font-size: 13px;
      font-weight: 500;
      letter-spacing: 0.05em;
      padding: 10px 20px;
      border: 1px solid #d0d0d0;
      background: transparent;
      color: var(--color-text-secondary);
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s ease;
    }

    .filter-tab.active {
      background: var(--color-text-secondary);
      color: var(--color-bg);
      border-color: var(--color-text-secondary);
    }

    .filter-tab:hover {
      background: var(--color-accent);
      color: var(--color-bg);
      border-color: var(--color-accent);
    }

    .archive-section {
      margin-bottom: 80px;
    }

    .year-header {
      font-family: 'Outfit', sans-serif;
      font-size: 13px;
      font-weight: 700;
      letter-spacing: 0.15em;
      text-transform: uppercase;
      color: var(--color-accent);
      margin-bottom: 32px;
      padding-bottom: 12px;
      border-bottom: 2px solid var(--color-accent);
    }

    .archive-list {
      display: flex;
      flex-direction: column;
      gap: 36px;
    }

    .archive-item {
      text-decoration: none;
      display: block;
      padding-bottom: 36px;
      border-bottom: 1px solid #f0f0f0;
      transition: all 0.2s ease;
    }

    .archive-item:last-child {
      border-bottom: none;
    }

    .archive-item:hover {
      transform: translateX(4px);
    }

    .archive-date {
      font-family: 'Outfit', sans-serif;
      font-size: 12px;
      color: var(--color-text-light);
      margin-bottom: 12px;
      font-weight: 500;
    }

    .archive-title {
      font-family: 'Outfit', sans-serif;
      font-size: 26px;
      font-weight: 600;
      line-height: 1.3;
      color: var(--color-text-primary);
      margin-bottom: 8px;
      letter-spacing: -0.01em;
      transition: color 0.2s ease;
    }

    .archive-item:hover .archive-title {
      color: var(--color-accent);
    }

    .archive-excerpt {
      font-size: 18px;
      line-height: 1.6;
      color: var(--color-text-tertiary);
    }

    @media (max-width: 768px) {
      .archive-container {
        padding: 60px 24px 80px;
      }

      h1 {
        font-size: 36px;
      }

      .page-header {
        margin-bottom: 48px;
      }

      .search-box {
        margin-bottom: 48px;
        padding-bottom: 48px;
      }

      .filter-tabs {
        margin-bottom: 48px;
      }

      .archive-section {
        margin-bottom: 60px;
      }

      .archive-title {
        font-size: 22px;
      }
    }
  </style>

  <script type="module" define:vars={{ searchIndex }}>
    // searchIndex is now directly available from define:vars
    console.log('Archive search index loaded:', searchIndex.length, 'posts');

    let currentFilter = 'all';
    let matchingSlugs = new Set();

    // Archive filtering
    function filterArchive(type) {
      currentFilter = type;
      const items = document.querySelectorAll('.archive-item');
      const buttons = document.querySelectorAll('.filter-tab');

      // Update active filter button
      buttons.forEach(btn => btn.classList.remove('active'));
      if (event?.target) {
        event.target.classList.add('active');
      }

      // Filter items
      items.forEach(item => {
        const slug = item.getAttribute('href')?.replace('/posts/', '').replace('/', '') || '';
        const matchesType = type === 'all' || item.dataset.type === type;
        const matchesSearch = matchingSlugs.size === 0 || matchingSlugs.has(slug);

        if (matchesType && matchesSearch) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });

      // Hide empty year sections
      updateSectionVisibility();
    }

    // Full content search functionality
    const searchInput = document.getElementById('archive-search');
    if (searchInput) {
      searchInput.addEventListener('input', (e) => {
        const query = e.target.value.trim().toLowerCase();

        if (query.length === 0) {
          // Clear search - show all items based on current filter
          matchingSlugs.clear();
          filterItems();
          return;
        }

        if (query.length < 2) {
          return; // Wait for at least 2 characters
        }

        // Search through full content
        const results = searchIndex.filter(post => {
          const searchText = [
            post.title,
            post.content,
            post.description,
            ...post.tags
          ].join(' ').toLowerCase();

          return searchText.includes(query);
        });

        console.log('Found', results.length, 'results for:', query);

        // Store matching slugs
        matchingSlugs = new Set(results.map(r => r.slug));

        // Update visible items
        filterItems();
      });
    }

    function filterItems() {
      const items = document.querySelectorAll('.archive-item');

      items.forEach(item => {
        const slug = item.getAttribute('href')?.replace('/posts/', '').replace('/', '') || '';
        const matchesType = currentFilter === 'all' || item.dataset.type === currentFilter;
        const matchesSearch = matchingSlugs.size === 0 || matchingSlugs.has(slug);

        if (matchesType && matchesSearch) {
          item.style.display = 'block';
        } else {
          item.style.display = 'none';
        }
      });

      updateSectionVisibility();
    }

    function updateSectionVisibility() {
      const sections = document.querySelectorAll('.archive-section');
      sections.forEach(section => {
        const visibleItems = section.querySelectorAll('.archive-item[style="display: block"], .archive-item:not([style*="none"])');
        section.style.display = visibleItems.length > 0 ? 'block' : 'none';
      });
    }

    // Make filterArchive available globally
    window.filterArchive = filterArchive;
  </script>
</Base>